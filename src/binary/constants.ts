// src/binary/constants.ts

// Enum-like object for tag codes used in the binary format
export const TAGS = {
  LIST_EMPTY: 0,
  DICTIONARY_0: 236,
  DICTIONARY_1: 237,
  DICTIONARY_2: 238,
  DICTIONARY_3: 239,
  AD_JID: 247,
  LIST_8: 248,
  LIST_16: 249,
  JID_PAIR: 250,
  HEX_8: 251,
  BINARY_8: 252,
  BINARY_20: 253,
  BINARY_32: 254,
  NIBBLE_8: 255,
  PACKED_MAX: 127, // Adjusted based on Baileys logic for packed limits
  SINGLE_BYTE_MAX: 256,
  STREAM_END: 2, // Example, confirm if needed for client logic
};

// Single-byte tokens - strings mapped to a single byte code (index)
// Copied directly from Baileys - essential for compact representation
export const SINGLE_BYTE_TOKENS: (string | null)[] = [
  // 0-2 are special tags, see TAGS enum
  null,
  null,
  null,
  // 3-235 are single-byte tokens
  "account",
  "ack",
  "action",
  "active",
  "add",
  "after",
  "all",
  "allow",
  "apple",
  "audio",
  "auth",
  "author",
  "available", // 3-15
  "bad-protocol",
  "bad-request",
  "before",
  "body",
  "broadcast",
  "busy",
  "call",
  "cancel",
  "cart",
  "chat",
  "chatstate",
  "clean",
  "code",
  "composing",
  "config",
  "contacts",
  "count",
  "create", // 16-33
  "creation",
  "debug",
  "default",
  "delete",
  "delivery",
  "delta",
  "deny",
  "device",
  "device_list",
  "dialing",
  "digest",
  "dirty",
  "duplicate",
  "eph_setting",
  "ephemeral",
  "error",
  "event", // 34-51
  "expiration",
  "expired",
  "fail",
  "failure",
  "false",
  "favorites",
  "feature",
  "features",
  "feature_flags",
  "field",
  "first",
  "free",
  "from",
  "g.us",
  "get",
  "google",
  "group",
  "groups", // 52-69
  "groups_v2",
  "groupinfo",
  "hard",
  "has",
  "height",
  "hex",
  "host",
  "hostname",
  "ib",
  "id",
  "image",
  "img",
  "index",
  "internal-server-error",
  "ip4",
  "ip6",
  "is_new",
  "item", // 70-87
  "item-not-found",
  "jid",
  "key",
  "kind",
  "last",
  "leave",
  "live",
  "log",
  "logout",
  "map",
  "max",
  "membership",
  "message",
  "messages",
  "message_acks",
  "media",
  "media_conn",
  "meta", // 88-105
  "metadata",
  "method",
  "microsoft",
  "mimetype",
  "missing",
  "mix",
  "mobile",
  "modify",
  "mute",
  "name",
  "namespace",
  "net",
  "new",
  "next",
  "node",
  "nodes",
  "none",
  "not-acceptable", // 106-123
  "not-allowed",
  "not-authorized",
  "notification",
  "notify",
  "now",
  "null",
  "number",
  "offline",
  "order",
  "owner",
  "paid",
  "participant",
  "participants",
  "participating",
  "passive",
  "paused", // 124-141
  "picture",
  "pin",
  "ping",
  "pkmsg",
  "platform",
  "played",
  "policy-violation",
  "pop",
  "port",
  "presence",
  "preview",
  "privacy",
  "probe",
  "proceed",
  "product",
  "products",
  "promote", // 142-159
  "props",
  "protocol",
  "psa",
  "public",
  "push",
  "query",
  "qr",
  "raw",
  "read",
  "readreceipts",
  "reason",
  "receipt",
  "relay",
  "remote",
  "remove",
  "request",
  "required",
  "resource-constraint", // 160-177
  "resource",
  "response",
  "result",
  "retry",
  "rim",
  "s.whatsapp.net",
  "seconds",
  "security",
  "seen",
  "send",
  "server",
  "server-error",
  "service-unavailable",
  "set",
  "show",
  "silent",
  "skmsg", // 178-195
  "solid",
  "spam",
  "start",
  "status",
  "stream:error",
  "stream:features",
  "subject",
  "subscribe",
  "sync",
  "system-shutdown",
  "t",
  "tag",
  "terminate",
  "text",
  "thumbnail-direct",
  "thumbnail-hq", // 196-213
  "thumbnail-sha256",
  "thumbnail",
  "timeout",
  "timestamp",
  "tos",
  "true",
  "type",
  "unavailable",
  "unsubscribe",
  "unarchive",
  "uri",
  "url",
  "urn:xmpp:ping",
  "urn:xmpp:whatsapp:account",
  "urn:xmpp:whatsapp:dirty", // 214-231
  "urn:xmpp:whatsapp:mms",
  "urn:xmpp:whatsapp:push",
  "user",
  "user-not-found",
  "vcard", // 232-237 (ends before DICTIONARY tags)
  // Note: Baileys list might have slightly more here, adjust if needed based on specific errors/needs
];

// Double-byte tokens - More complex structure, often specific to WA internals
// Keep minimal initially, add more as specific features are implemented
// Copied a smaller subset from Baileys for initial connection/auth
export const DOUBLE_BYTE_TOKENS: string[][] = [
  // Dictionary 0 (236)
  [
    // Copied first ~60 from Baileys dict 0 for basic functionality
    "account_sync",
    "admin",
    "announcement",
    "audio",
    "call",
    "call-id",
    "call-key",
    "calls",
    "read",
    "played",
    "canonical",
    "cart",
    "catalog",
    "catalog_not_created",
    "category",
    "challenge",
    "chat",
    "chatstate",
    "ciphertext",
    "clear",
    "code",
    "composing",
    "config",
    "config_code",
    "config_value",
    "contact",
    "contacts",
    "content",
    "count",
    "country_code",
    "create",
    "creation",
    "currency",
    "dhash",
    "delete",
    "demote",
    "description",
    "device",
    "device_fanout",
    "devices",
    "directed_paths",
    "dirty",
    "document",
    "edit",
    "elapsed",
    "enable",
    "encoding",
    "encrypt",
    "ephemeral",
    "ephemeral_setting",
    "error",
    "event",
    "expiration",
    "false",
    "favorites",
    "feature",
    "features",
    "fieldstats",
    "file",
    "final",
    "first",
    "free_space",
    "from_ip",
    "gcm",
    // ... add more as needed based on required features (like group info, presence, etc.)
  ],
  // Dictionary 1 (237)
  [
    // Add tokens from Baileys dict 1 if needed
  ],
  // Dictionary 2 (238)
  [
    // Add tokens from Baileys dict 2 if needed
  ],
  // Dictionary 3 (239)
  [
    // Add tokens from Baileys dict 3 if needed
  ],
];

// Create a reverse map for encoding efficiency
// Maps string -> { dict?: number, index: number }
export const TOKEN_MAP: { [token: string]: { dict?: number; index: number } } =
  {};

// Populate TOKEN_MAP from single-byte tokens
SINGLE_BYTE_TOKENS.forEach((token, i) => {
  if (token) {
    TOKEN_MAP[token] = { index: i };
  }
});

// Populate TOKEN_MAP from double-byte tokens
DOUBLE_BYTE_TOKENS.forEach((dict, i) => {
  dict.forEach((token, j) => {
    TOKEN_MAP[token] = { dict: i, index: j };
  });
});
